"""
billeterapp 2.0 - Junio 2024

This module handles the model of accounts.
Creation of one dedicated directory and database for every user created and
their corresponding accounts table and a new table for each user account.

This module is intended to be used by the module commands and not directly.

"""

import os
import re
import sqlite3
import datetime
from decimal import Decimal
from typing import Optional

from ulid import ULID
from pydantic import BaseModel, Field, field_validator
from pydantic_extra_types.currency_code import ISO4217

# custom sqlite3 adapter for date and datetime
sqlite3.register_adapter(datetime.date, lambda val: val.isoformat())
sqlite3.register_adapter(datetime.datetime, lambda val: val.isoformat())
# custom sqlite3 adapter for decimals
sqlite3.register_adapter(Decimal, lambda val: str(val))
# custom sqlite3 converter for deicmals
sqlite3.register_converter("DECIMAL", lambda val: Decimal(val))


class AccountNotFoundError(Exception):
    pass


class InvalidAccountNameError(Exception):
    pass


class UserAccounts(BaseModel, validate_assignment=True):
    """
    UserAccounts model: Handle the lower level operations of the database for user accounts and the account entries.

    It handles the creation of the accounts_database.db which will hold the following tables:
        - accounts -> user accounts list: contains basic data of all created accounts
        - <account_name_[currency]> : contains operations done for the user on that account (incomes, expenses, etc.)

    Args:
        user_id (str): The unique identifier for the user generated by the library ULID.
        account_id (int, optional): account id. Is optional because it will be created on the fly by the db.
        account_name (str): Name of the account.
        account_currency (str): ISO 4217 currency code, e.g.: ARS, USD, EUR.
        created_at (datetime.datetime, optional): Optional because it should not be user provided.
        updated_at (datetime.datetime, optional): Optional because it should not be user provided.
    """

    user_id: str
    account_id: str = Field(default_factory=lambda: "acc_" + str(ULID()))
    account_name: Optional[str] = None
    account_currency: Optional[ISO4217] = None
    account_total: Optional[Decimal] = None
    is_active: bool = Field(default=True)
    created_at: Optional[datetime.datetime] = None
    updated_at: Optional[datetime.datetime] = None

    @staticmethod
    def __db_path(user_id) -> str:
        """Stablished the path for the accounts_database.db"""
        return os.path.join("data", user_id, "accounts_database.db")

    @field_validator("account_name")
    @classmethod
    def __name_validator(cls, acc_name) -> str:
        """
        Validates names of the account or the table if they have only alphanumeric chars and underscores for
        security reasons.

        Args:
            acc_name (str): Name of the account.

        Returns:
            str: Name of the account.
        """
        if not re.match(r"^[a-zA-Z0-9_]*$", acc_name):
            raise InvalidAccountNameError
        return acc_name

    @classmethod
    def get_account_by_id(cls, user_id: str, account_id: str) -> "UserAccounts":
        """
        Fetches account info from db and returns an UserAccount object that matches the id provided.

        Args:
            user_id (str): The unique identifier for the user generated by the library ULID.
            account_id (str): The unique identifier for the account generated by the library ULID.

        Returns:
            UserAccount: An UserAccount object with that account columns that matches the id provided.
        """
        conn = sqlite3.connect(os.getenv("ACC_DATABASE_NAME", UserAccounts.__db_path(user_id)))
        conn.row_factory = sqlite3.Row

        cur = conn.cursor()
        cur.execute("SELECT * FROM accounts WHERE account_id = ?", (account_id,))

        record = cur.fetchone()
        conn.close()

        if not record:
            raise AccountNotFoundError

        account = cls(**record)

        return account

    @classmethod
    def get_account_by_table_name(cls, user_id: str, table_name: str) -> "UserAccounts":
        """
        Fetches account info from db and returns an UserAccount object that matches the table_name provided.

        Args:
            user_id (str): The unique identifier for the user generated by the library ULID.
            table_name (str): The name of the table of the form '<account_name>_<account_currency>'

        Returns:
            UserAccount: An UserAccount object with that account columns that matches the table_name provided.
        """
        table_name = UserAccounts.__name_validator(table_name)

        conn = sqlite3.connect(os.getenv("ACC_DATABASE_NAME", UserAccounts.__db_path(user_id)))
        conn.row_factory = sqlite3.Row

        cur = conn.cursor()
        cur.execute("SELECT * FROM accounts WHERE table_name = ?", (table_name,))

        record = cur.fetchone()
        conn.close()

        if not record:
            raise AccountNotFoundError

        account = cls(**record)

        return account

    @classmethod
    def get_all_accounts(cls, user_id: str, **kwargs: int | str) -> list["UserAccounts"]:
        """
        Returns all the accounts for a given user.

        Args:
            user_id (str): The unique identifier for the user generated by the library ULID.
        Kwargs:
            acitve (int, optional): sets the "is_active" clause to 0 or 1 to fetch active or inactive accounts
            currency (str, optional): strs the "account_currency" clause to fetch all accounts of the same currency
        Returns:
            list[UserAccount]: A list of all the UserAccount objects for the user.
        """
        conn = sqlite3.connect(os.getenv("ACC_DATABASE_NAME", UserAccounts.__db_path(user_id)))
        conn.row_factory = sqlite3.Row

        select_query = "SELECT * FROM accounts"
        query_conditions = []
        query_parameters = []

        if kwargs:
            if "active" in kwargs:
                query_conditions.append("is_active = ?")
                query_parameters.append(kwargs["active"])

            if "currency" in kwargs:
                query_conditions.append("account_currency = ?")
                query_parameters.append(kwargs["currency"])

            if query_conditions:
                select_query += " WHERE " + " AND ".join(query_conditions)

        cur = conn.cursor()
        cur.execute(select_query, query_parameters)

        records = cur.fetchall()
        conn.close()

        accounts = [cls(**record) for record in records]

        return accounts

    @classmethod
    def create_acc_list_table(cls, user_id: str) -> None:
        """
        Creates the directory for a new user and the database for its accounts.

        Args:
            user_id (str): User id, used in the name of the directory containing the database.
            database_name (str, optional): The name of the database. Defaults to "accounts_database.db".

        Database name is the same for every user.
        Database columns are:
            account_id -> primary key acc_ULID
            user_id -> text (not used as foreing key, accounts_table does not need to know anything about users table)
            account_name -> text not null
            account_currency -> text not null (3 chars, ISO 4217)
            table_name -> text not null (account_name + account_currency)
            account_total -> real not null
            is_active -> bool
            created_at -> datetime
            updated_at -> datetime
        """
        conn = sqlite3.connect(os.getenv("ACC_DATABASE_NAME", UserAccounts.__db_path(user_id)))
        cur = conn.cursor()
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS accounts (
              account_id TEXT PRIMARY KEY,
              user_id TEXT NOT NULL,
              account_name TEXT NOT NULL,
              account_currency TEXT NOT NULL,
              table_name TEXT NOT NULL UNIQUE,
              account_total DECIMAL,
              is_active BOOLEAN NOT NULL CHECK (is_active IN (0, 1)),
              created_at DATETIME,
              updated_at DATETIME
            )"""
        )
        conn.commit()
        conn.close()

    def create_account_operations_tables(self) -> None:
        """
        Takes care of the creation of the operations related tables: account operations tables (one per account),
        operation_groups table (one for all accounts) and operation_details table (one for all acounts).

        The names of the account operations tables are user inputs and have restrictions for security reasons.

        Args:
            self

        Database columns are:
            operation_id -> primary key op_ULID
            operation_datetime -> datetime
            cumulative_amount -> real
            amount -> real
            operation_type -> text
            category -> text
            subcategory -> text
            description -> text
            tags -> text
            group_id -> text/foreing key referencing operation_groups table
            detail_id -> text/foreing key referencing operation_details table
            created_at -> datetime
            updated_at -> datetime
        """

        self.created_at = self.updated_at = datetime.datetime.now(datetime.UTC)

        table_name = f"{self.account_name}_{self.account_currency}"

        conn = sqlite3.connect(os.getenv("ACC_DATABASE_NAME", UserAccounts.__db_path(self.user_id)))
        cur = conn.cursor()
        # creation of the the account (operations) table and the operation_groups table
        try:
            cur.execute("BEGIN TRANSACTION")
            # account operations table
            cur.execute(
                f"""
                CREATE TABLE IF NOT EXISTS {table_name} (
                operation_id TEXT PRIMARY KEY,
                operation_datetime DATETIME NOT NULL,
                cumulative_amount DECIMAL NOT NULL,
                amount DECIMAL NOT NULL,
                operation_type TEXT NOT NULL,
                category TEXT,
                subcategory TEXT,
                description TEXT,
                tags TEXT,
                group_id TEXT,
                detail_id TEXT,
                created_at DATETIME,
                updated_at DATETIME,
                FOREIGN KEY (group_id) REFERENCES operation_groups (group_id) ON DELETE SET NULL, 
                FOREIGN KEY (detail_id) REFERENCES operation_details (detail_id) ON DELETE SET NULL
                )"""
            )
            # operation groups table
            cur.execute(
                """
                CREATE TABLE IF NOT EXISTS operation_groups (
                group_id TEXT PRIMARY KEY,
                user_id TEXT,
                group_datetime DATETIME NOT NULL,
                group_name TEXT NOT NULL,
                group_currency TEXT NOT NULL,
                original_amount DECIMAL,
                category TEXT,
                subcategory TEXT,
                description TEXT,
                status TEXT NOT NULL,
                created_at DATETIME,
                updated_at DATETIME
                )
                """
            )
            # operation details table
            cur.execute(
                """
                CREATE TABLE IF NOT EXISTS operation_details (
                detail_id TEXT PRIMARY KEY,
                operation_id TEXT NOT NULL,
                account_id TEXT NOT NULL,
                details BLOB NOT NULL,
                created_at DATETIME,
                updated_at DATETIME
                )"""
            )
            # insert new account operations table name into accounts table
            cur.execute(
                """
                INSERT INTO accounts
                  (account_id,
                  user_id,
                  account_name,
                  account_currency,
                  table_name,
                  is_active,
                  created_at,
                  updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """,
                (
                    self.account_id,
                    self.user_id,
                    self.account_name,
                    self.account_currency,
                    table_name,
                    self.is_active,
                    self.created_at,
                    self.updated_at,
                ),
            )
            conn.commit()
        except sqlite3.Error:
            conn.rollback()
        finally:
            conn.close()
        return self

    def save(self, change_table_name_flag: bool = False) -> "UserAccounts":
        """
        Saves modifications to user account data in the database such as account_name and account_currency
        and table_name for posible mistakes when creating them.

        Args:
            self (UserAccount): An User object.
        Returns:
            UserAccount: An UserAccount object.
        """
        self.updated_at = datetime.datetime.now(datetime.UTC)

        table_name = f"{self.account_name}_{self.account_currency}"

        with sqlite3.connect(os.getenv("ACC_DATABASE_NAME", UserAccounts.__db_path(self.user_id))) as conn:
            cur = conn.cursor()
            if change_table_name_flag:
                cur.execute("SELECT table_name FROM accounts WHERE account_id = ?", (self.account_id,))
                old_table_name = cur.fetchone()[0]
                cur.execute(f"ALTER TABLE {old_table_name} RENAME TO {table_name}")
            cur.execute(
                """
                UPDATE
                  accounts
                SET
                  account_name = ?,
                  account_currency = ?,
                  table_name = ?,
                  account_total = ?,
                  is_active = ?,
                  updated_at = ?
                WHERE
                  account_id = ?
                """,
                (
                    self.account_name,
                    self.account_currency,
                    table_name,
                    self.account_total,
                    self.is_active,
                    self.updated_at,
                    self.account_id,
                ),
            )
            conn.commit()
        conn.close()
        return self

    @classmethod
    def delete_account(cls, user_id: str, account_id: str) -> None:
        """
        Deletes a given account: Removes the account entry in the accounts table and deletes de tabe
        Args:
            self (UserAccount): An User object.
        Returns:
            UserAccount: An UserAccount object.
        """
        conn = sqlite3.connect(os.getenv("ACC_DATABASE_NAME", UserAccounts.__db_path(user_id)))
        cur = conn.cursor()
        try:
            cur.execute("BEGIN TRANSACTION")
            cur.execute("SELECT table_name FROM accounts WHERE account_id = ?", (account_id,))
            table_name = cur.fetchone()[0]
            cur.execute(f"DROP TABLE {table_name}")
            cur.execute("DELETE FROM accounts WHERE account_id = ?", (account_id,))
            conn.commit()
        except sqlite3.Error:
            conn.rollback()
        finally:
            conn.close()
