"""
billeterapp 2.0 - Junio 2024

This module handles the models of users and accounts.
Creation of the users database and the table "users" in the main directory.

This module is intended to be used by the module commands and not directly.
"""

import os
import sqlite3
import datetime
from typing import Optional, List

from ulid import ULID
from pydantic import BaseModel, EmailStr, Field, constr

from src.pwhandler.pwhandler import verify_password, UnauthorizedError

# custom sqlite3 adapter for date and datetime
sqlite3.register_adapter(datetime.date, lambda val: val.isoformat())
sqlite3.register_adapter(datetime.datetime, lambda val: val.isoformat())


class UserNotFoundError(Exception):
    pass


class User(BaseModel, validate_assignment=True):
    """
    User model: Handle the lower level main operations of the database for users and the user entries.

    Args:
        user_id (str): The unique identifier for the user generated by the library ULID.
        first_name (str): First name of the user.
        last_name (str, optional): Optional at creation, last name of the user.
        birthdate (datetime.date): Optional at creation, birth year of the user.
        gender (str, optional): Optional at creation, gender of the user.
        region (str, optional): Optional at creation, region of the user ISO 3166-1-alfa3 (3 chars, e.g.: ARG).
        email (str): EmailStr validation from pydantic.
        password (str, optional): Optional field by design but mandatory at creation. If it wouldn't be optional,
            then the returning value of get_user_by_... methods would disclose the hashed password.
        created_at (datetime.datetime, optional): UTC datetime. Optional because it should not be user provided.
        updated_at (datetime.datetime, optional): UTC datetime. Optional because it should not be user provided.
    """

    user_id: str = Field(default_factory=lambda: "user_" + str(ULID()))
    first_name: str
    last_name: Optional[str] = None
    birthdate: Optional[datetime.date] = None
    gender: Optional[str] = None
    region: Optional[constr(min_length=3, max_length=3)] = Field(default=None, description="The ISO 3166-1-alfa3 country code.")  # type: ignore
    email: EmailStr
    password: Optional[str] = None  # Already hashed password only
    created_at: Optional[datetime.datetime] = None
    updated_at: Optional[datetime.datetime] = None

    def __get_password(self) -> str:
        """
        Private method to get the password of a given user

        Args:
            self (User): An User object.
        Returns:
            str: The password of the user
        """
        conn = sqlite3.connect(os.getenv("DATABASE_NAME", "data/database.db"))
        conn.row_factory = sqlite3.Row

        cur = conn.cursor()
        cur.execute("SELECT password FROM users WHERE user_id = ?", (self.user_id,))
        passwd = cur.fetchone()
        conn.close()

        if not passwd:
            raise UserNotFoundError

        return passwd

    @classmethod
    def get_user_by_id(cls, user_id: str) -> "User":
        """
        Fetches user from db and returns an User object that matches the id provided.

        Args:
            user_id (str): The unique identifier for the user generated by the library ULID.

        Returns:
            User: An User object that matches the id provided.
        """
        conn = sqlite3.connect(os.getenv("DATABASE_NAME", "data/database.db"))
        conn.row_factory = sqlite3.Row

        cur = conn.cursor()
        cur.execute(
            """
            SELECT
              user_id,
              first_name,
              last_name,
              birthdate,
              gender,
              region,
              email,
              created_at,
              updated_at
            FROM
              users
            WHERE
              user_id = ?
            """,
            (user_id,),
        )

        record = cur.fetchone()
        conn.close()

        if not record:
            raise UserNotFoundError

        user = cls(**record)

        return user

    @classmethod
    def get_user_by_email(cls, user_email: str) -> "User":
        """
        Fetches user from db and returns an User object that matches the email provided.

        Args:
            user_email (EmailStr): The email of the user, that is unique constrainted in the database.

        Returns:
            User: An User object that matches the email provided.
        """
        conn = sqlite3.connect(os.getenv("DATABASE_NAME", "data/database.db"))
        conn.row_factory = sqlite3.Row

        cur = conn.cursor()
        cur.execute(
            """
            SELECT
              user_id,
              first_name,
              last_name,
              birthdate,
              gender,
              region,
              email,
              created_at,
              updated_at
            FROM
              users
            WHERE
              email = ?
            """,
            (user_email,),
        )

        record = cur.fetchone()
        conn.close()

        if not record:
            raise UserNotFoundError

        user = cls(**record)

        return user

    @classmethod
    def get_all_users(cls) -> List["User"]:
        """
        Fetches all users from db and returns a list of User objects.

        Returns:
            List[User]: A list of User objects.
        """
        conn = sqlite3.connect(os.getenv("DATABASE_NAME", "data/database.db"))
        conn.row_factory = sqlite3.Row

        cur = conn.cursor()
        cur.execute(
            """
            SELECT
              user_id,
              first_name,
              last_name,
              birthdate,
              gender,
              region,
              email,
              created_at,
              updated_at
            FROM
              users
            """
        )

        records = cur.fetchall()
        conn.close()

        users = [cls(**record) for record in records]

        return users

    def create(self) -> "User":
        """
        Creates the user in the database.

        Args:
            self (User): An User object.
        Returns:
            self (User): An User object.
        """
        self.created_at = self.updated_at = datetime.datetime.now(datetime.UTC)
        with sqlite3.connect(os.getenv("DATABASE_NAME", "data/database.db")) as conn:
            cur = conn.cursor()
            cur.execute(
                """
                INSERT INTO users
                  (user_id, first_name, last_name, birthdate, gender, region, email, password, created_at, updated_at)
                VALUES
                  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """,
                (
                    self.user_id,
                    self.first_name,
                    self.last_name,
                    self.birthdate,
                    self.gender,
                    self.region,
                    self.email,
                    self.password,
                    self.created_at,
                    self.updated_at,
                ),
            )
            conn.commit()
        conn.close()
        return self

    def save(self) -> "User":
        """
        Saves modifications to user data in the database. Uses user_id for matching.

        Args:
            self (User): An User object.
        Returns:
            User: An User object.
        """
        self.updated_at = datetime.datetime.now(datetime.UTC)

        with sqlite3.connect(os.getenv("DATABASE_NAME", "data/database.db")) as conn:
            cur = conn.cursor()
            cur.execute(
                """
                UPDATE
                  users
                SET
                  first_name = ?,
                  last_name = ?,
                  birthdate = ?,
                  gender = ?,
                  region = ?,
                  email = ?,
                  updated_at = ?
                WHERE
                  user_id = ?
                """,
                (
                    self.first_name,
                    self.last_name,
                    self.birthdate,
                    self.gender,
                    self.region,
                    self.email,
                    self.updated_at,
                    self.user_id,
                ),
            )
            conn.commit()
        conn.close()
        return self

    @classmethod
    def delete(cls, user_id: str, password: str) -> None:
        """
        Deletes user from db using the user_id for matching.

        Args:
            user_id (str): The unique identifier for the user generated by the library ULID.
        """
        user = User.get_user_by_id(user_id)

        stored_password = user.__get_password()["password"]

        if not verify_password(stored_password, password):
            raise UnauthorizedError

        conn = sqlite3.connect(os.getenv("DATABASE_NAME", "data/database.db"))
        cur = conn.cursor()

        cur.execute("DELETE FROM users WHERE user_id = ?", (user_id,))
        conn.commit()
        conn.close()

    @classmethod
    def authenticate(cls, user_id: str, password: str) -> bool:
        """
        Authenticates the user if the password is correct.

        Args:
            user_id (str): the unique identifier for the user generated by the library ULID.
            password (str): the entered password to be checked (before hashing).
        """
        user = User.get_user_by_id(user_id)

        stored_password = user.__get_password()["password"]

        if verify_password(stored_password, password):
            return True
        else:
            raise UnauthorizedError

    @classmethod
    def create_table(cls, database_name: str = "database.db") -> None:
        """
        Creates the users table in the database.

        Args:
            database_name (str, optional): The name of the database. Defaults to "data/database.db".

        Database columns are:
            user_id -> primary key user_ULID
            first_name -> text not null
            last_name -> text
            birthdate -> text
            gender -> text
            region -> text
            email -> text not null
            password -> text
            created_at -> datetime in utc
            updated_at -> datetime in utc
        """
        db_path = os.path.join("data", database_name)

        conn = sqlite3.connect(db_path)
        cur = conn.cursor()
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS users (
              user_id TEXT PRIMARY KEY,
              first_name TEXT NOT NULL,
              last_name TEXT,
              birthdate DATE,
              gender TEXT,
              region TEXT,
              email TEXT NOT NULL UNIQUE,
              password TEXT,
              created_at DATETIME,
              updated_at DATETIME
            )"""
        )
        conn.commit()
        conn.close()
