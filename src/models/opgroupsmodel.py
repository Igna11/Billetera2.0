"""
billeterapp 2.0 - Agosto 2025

This module handles the way operations group are stored into de database.

The main idea is that a table called 'operation_groups' is created to store linked operations with their amounts
so it is easy to fetch information about 'currency flow' and 'real expenses/incomes'. The easiest example are 
loans: If user A lends money to user B, it is not necesarily a real expense, because user B will reimburst to 
user A in another time. But it is a flow o money. The real expense, if user B repays the total to user A, would be 0.
"""

import os
import sqlite3
from datetime import datetime, date, UTC
from decimal import Decimal
from typing import Optional, Literal, List

from ulid import ULID
from pydantic import BaseModel, Field
from pydantic_extra_types.currency_code import ISO4217

# custom sqlite3 adapter for date and datetime
sqlite3.register_adapter(date, lambda val: val.isoformat())
sqlite3.register_adapter(datetime, lambda val: val.isoformat())


class GroupNotFoundError(Exception):
    pass


class OperationGroups(BaseModel, validate_assignment=True):

    group_id: str = Field(default_factory=lambda: "group_" + str(ULID()))
    user_id: Optional[str] = None
    group_datetime: Optional[datetime] = Field(default_factory=lambda: datetime.now(UTC))
    group_name: Optional[str] = None
    group_currency: Optional[ISO4217] = None
    original_amount: Optional[Decimal] = None
    category: Optional[str] = None
    subcategory: Optional[str] = None
    description: Optional[str] = None
    status: Optional[Literal["open", "closed", "cancelled"]] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    @staticmethod
    def __db_path(user_id) -> str:
        """Stablished the path for the accounts_database.db"""
        return os.path.join("data", user_id, "accounts_database.db")

    @classmethod
    def get_group_by_id(cls, user_id: str, group_id: str) -> "OperationGroups":
        """
        Fetches a given group from db and returns an OperationGroups object that matches the id provided.

        Args:
            user_id (str): The unique identifier for the user.
            group_id (str): The unique identifier for the group, generated by the library ULID.
        Returns:
            OperationGroups: An OperationGroups object with that operation data.
        """
        db_path = os.path.join("data", user_id, "accounts_database.db")

        conn = sqlite3.connect(os.getenv("ACC_DATABASE_NAME", db_path))
        conn.row_factory = sqlite3.Row

        cur = conn.cursor()
        cur.execute("SELECT * FROM operation_groups WHERE group_id = ?", (group_id,))

        record = cur.fetchone()
        conn.close()

        if not record:
            raise GroupNotFoundError

        record = dict(record)

        group = cls(**record)

        return group

    @classmethod
    def get_groups_list(cls, user_id: str, status: str | None = None) -> List["OperationGroups"]:
        """
        Fetches all groups from db and returns a list of OperationGroups objects.

        Args:
            user_id (str): The unique identifier for the user
        Returns:
            list[UserOperation]: A list of UserOperation objects for a given account.
        """
        db_path = os.path.join("data", user_id, "accounts_database.db")

        conn = sqlite3.connect(os.getenv("ACC_DATABASE_NAME", db_path))
        conn.row_factory = sqlite3.Row

        cur = conn.cursor()

        if status == "open":
            cur.execute("SELECT * FROM operation_groups WHERE status = 'open';")
        elif status == "closed":
            cur.execute("SELECT * FROM operation_groups WHERE status = 'closed';")
        elif status == "cancelled":
            cur.execute("SELECT * FROM operation_groups WHERE status = 'cancelled';")
        else:
            cur.execute("SELECT * FROM operation_groups;")

        records = cur.fetchall()
        conn.close()

        groups = [cls(**record) for record in records]

        return groups

    def create(self, database_name="accounts_database.db") -> "OperationGroups":
        """
        Creates the group of operations in the database

        Args:
            self (OperationGroups): An OperationGroups object.
        Returns:
            self (OperationGroups): An OperationGroups object.
        """
        db_path = os.path.join("data", self.user_id, database_name)

        self.created_at = self.updated_at = datetime.now(UTC)

        with sqlite3.connect(os.getenv("ACC_DATABASE_NAME", db_path)) as conn:
            cur = conn.cursor()
            cur.execute(
                """
                INSERT INTO operation_groups (
                  group_id, 
                  user_id,
                  group_datetime,
                  group_name,
                  group_currency,
                  original_amount,
                  category,
                  subcategory,
                  description,
                  status,
                  created_at,
                  updated_at
                  )
                VALUES
                  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """,
                (
                    self.group_id,
                    self.user_id,
                    self.group_datetime,
                    self.group_name,
                    self.group_currency,
                    self.original_amount,
                    self.category,
                    self.subcategory,
                    self.description,
                    self.status,
                    self.created_at,
                    self.updated_at,
                ),
            )
            conn.commit()
        conn.close()
        return self

    def save(self) -> "OperationGroups":
        """
        Saves changes into the group.

        Args:
            self (OperationGroups): An OperationGroups object.
        Returns:
            self (OperationGroups): An OperationGroups object.
        """
        db_path = os.path.join("data", self.user_id, "accounts_database.db")

        self.updated_at = datetime.now(UTC)

        with sqlite3.connect(os.getenv("ACC_DATABASE_NAME", db_path)) as conn:
            cur = conn.cursor()
            cur.execute(
                """
                UPDATE operation_groups
                  SET 
                  group_datetime = ?,
                  group_name = ?,
                  group_currency = ?,
                  original_amount = ?,
                  category = ?,
                  subcategory = ?,
                  description = ?,
                  status = ?,
                  updated_at = ?
                WHERE group_id = ?
                """,
                (
                    self.group_datetime,
                    self.group_name,
                    self.group_currency,
                    self.original_amount,
                    self.category,
                    self.subcategory,
                    self.description,
                    self.status,
                    self.updated_at,
                    self.group_id,
                ),
            )
            conn.commit()
        conn.close()
        return self

    def delete(self) -> None:
        """
        Deletes a given group.

        Args:
            self (OperationGroups): An OperationGroups object used to extract the group_id.
        """
        db_path = os.path.join("data", self.user_id, "accounts_database.db")

        conn = sqlite3.connect(os.getenv("ACC_DATABASE_NAME", db_path))
        cur = conn.cursor()

        cur.execute("PRAGMA foreign_keys = ON;")  # activate the foreing keys enforcement
        cur.execute("DELETE FROM operation_groups WHERE group_id = ?", (self.group_id,))
        conn.commit()
        conn.close()
